"""
Frontend de Teste - Sistema HELIO
Interface simples para testar Agentes 0 e 1 com implementa√ß√µes reais
"""

import streamlit as st
import asyncio
import sys
import os
import tempfile
from datetime import datetime
import json

# Adiciona o diret√≥rio raiz ao path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from core.services.document_processor import DocumentProcessor
from core.services.ai_validator import AIValidator
from core.services.job_scraper import JobScraper

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="HELIO - Teste dos Agentes",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS customizado
st.markdown("""
<style>
    .main-header {
        text-align: center;
        padding: 1rem;
        background: linear-gradient(90deg, #1f77b4, #ff7f0e);
        color: white;
        border-radius: 10px;
        margin-bottom: 2rem;
    }
    .agent-card {
        border: 2px solid #e0e0e0;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        background-color: #f9f9f9;
    }
    .success-box {
        border: 2px solid #4CAF50;
        border-radius: 5px;
        padding: 1rem;
        background-color: #e8f5e8;
        color: #2e7d32;
    }
    .error-box {
        border: 2px solid #f44336;
        border-radius: 5px;
        padding: 1rem;
        background-color: #ffeaea;
        color: #c62828;
    }
    .info-box {
        border: 2px solid #2196F3;
        border-radius: 5px;
        padding: 1rem;
        background-color: #e3f2fd;
        color: #1565c0;
    }
</style>
""", unsafe_allow_html=True)

def main():
    # Header principal
    st.markdown("""
    <div class="main-header">
        <h1>üöÄ HELIO - Sistema de Carreira Mete√≥rica</h1>
        <p>Teste das Implementa√ß√µes Reais - Metodologia Carolina Martins</p>
    </div>
    """, unsafe_allow_html=True)

    # Sidebar para configura√ß√µes
    with st.sidebar:
        st.header("‚öôÔ∏è Configura√ß√µes")
        
        # Status das APIs
        st.subheader("üîå Status das APIs")
        
        openai_key = os.getenv('OPENAI_API_KEY', '')
        anthropic_key = os.getenv('ANTHROPIC_API_KEY', '')
        
        if openai_key and openai_key != 'your_openai_api_key_here':
            st.success("‚úÖ OpenAI configurada")
        else:
            st.warning("‚ö†Ô∏è OpenAI n√£o configurada")
            
        if anthropic_key and anthropic_key != 'your_anthropic_api_key_here':
            st.success("‚úÖ Anthropic configurada")
        else:
            st.warning("‚ö†Ô∏è Anthropic n√£o configurada")
        
        if not (openai_key and openai_key != 'your_openai_api_key_here') and not (anthropic_key and anthropic_key != 'your_anthropic_api_key_here'):
            st.error("‚ùå Nenhuma API de IA configurada. Sistema usar√° fallbacks.")

    # Tabs principais
    tab1, tab2, tab3 = st.tabs(["ü©∫ Agente 0 - Diagn√≥stico", "üîç Agente 1 - MPC", "üìä Resultados Integrados"])
    
    with tab1:
        testar_agente_0()
    
    with tab2:
        testar_agente_1()
    
    with tab3:
        testar_integracao()

def testar_agente_0():
    """Interface para testar o Agente 0 - Diagn√≥stico"""
    
    st.header("ü©∫ Agente 0 - Diagn√≥stico e Onboarding")
    st.markdown("**Teste o processamento real de curr√≠culos seguindo a metodologia Carolina Martins**")
    
    col1, col2 = st.columns([1, 1])
    
    with col1:
        st.subheader("üìÑ Upload de Curr√≠culo")
        
        # Upload de arquivo
        uploaded_file = st.file_uploader(
            "Escolha um arquivo de curr√≠culo",
            type=['pdf', 'docx', 'doc'],
            help="Formatos suportados: PDF, DOCX, DOC"
        )
        
        # Op√ß√£o de texto direto
        st.subheader("‚úèÔ∏è Ou Cole o Texto do Curr√≠culo")
        texto_curriculo = st.text_area(
            "Cole o conte√∫do do curr√≠culo aqui:",
            height=200,
            placeholder="JO√ÉO SILVA\nEmail: joao@email.com\nObjetivo: Analista de Marketing\n\nExperi√™ncia:\n2020-2024 - Analista - Empresa ABC\n- Gerenciei campanhas com ROI de 150%\n- Liderei equipe de 3 pessoas..."
        )
        
        # Bot√£o de an√°lise
        if st.button("üîç Analisar Curr√≠culo", type="primary"):
            if uploaded_file or texto_curriculo.strip():
                processar_curriculo(uploaded_file, texto_curriculo)
            else:
                st.error("Por favor, fa√ßa upload de um arquivo ou cole o texto do curr√≠culo.")
    
    with col2:
        st.subheader("üìã O que ser√° analisado:")
        st.markdown("""
        **Estrutura Metodol√≥gica (13 Passos):**
        - ‚úÖ Dados Pessoais
        - ‚úÖ Objetivo Profissional  
        - ‚úÖ Resumo/Perfil
        - ‚úÖ Experi√™ncias Profissionais
        - ‚úÖ Resultados Quantificados
        - ‚úÖ Forma√ß√£o Acad√™mica
        - ‚úÖ Idiomas
        - ‚úÖ Compet√™ncias T√©cnicas
        - ‚úÖ Outros Conhecimentos
        - ‚úÖ Trabalho Volunt√°rio
        
        **Valida√ß√µes de Honestidade:**
        - üîç Consist√™ncia de datas
        - üìä Informa√ß√µes verific√°veis
        - üìù N√≠vel de detalhamento
        - ‚ö° Uso de verbos de a√ß√£o
        
        **Score de Qualidade:**
        - üéØ Metodologia (40%)
        - üé® Formata√ß√£o (20%)
        - ‚úÖ Honestidade (30%)
        - üîë Palavras-chave (10%)
        """)

def processar_curriculo(uploaded_file, texto_curriculo):
    """Processa o curr√≠culo usando o Document Processor real"""
    
    with st.spinner("üîÑ Processando curr√≠culo..."):
        try:
            processor = DocumentProcessor()
            
            # Determina se √© arquivo ou texto
            if uploaded_file:
                # Salva arquivo temporariamente
                with tempfile.NamedTemporaryFile(delete=False, suffix=f".{uploaded_file.name.split('.')[-1]}") as tmp_file:
                    tmp_file.write(uploaded_file.getvalue())
                    tmp_path = tmp_file.name
                
                # Extrai texto do arquivo
                texto_extraido = processor.extrair_texto_documento(tmp_path)
                os.unlink(tmp_path)  # Remove arquivo tempor√°rio
                
                if not texto_extraido.strip():
                    st.error("‚ùå N√£o foi poss√≠vel extrair texto do arquivo. Verifique se o arquivo n√£o est√° corrompido.")
                    return
                
                st.success(f"‚úÖ Texto extra√≠do com sucesso! {len(texto_extraido)} caracteres")
                
            else:
                texto_extraido = texto_curriculo
            
            # An√°lises
            col1, col2 = st.columns([1, 1])
            
            with col1:
                st.subheader("üìä An√°lise Estrutural")
                estrutura = processor.analisar_estrutura_curriculo(texto_extraido)
                
                # Score geral
                score = estrutura['score_metodologia']
                if score >= 80:
                    cor = "üü¢"
                    status = "Excelente"
                elif score >= 60:
                    cor = "üü°"
                    status = "Bom"
                else:
                    cor = "üî¥"
                    status = "Necessita melhorias"
                
                st.markdown(f"""
                <div class="success-box">
                    <h3>{cor} Score Metodol√≥gico: {score:.1f}%</h3>
                    <p><strong>Status:</strong> {status}</p>
                    <p><strong>Elementos presentes:</strong> {estrutura['elementos_presentes']}/{estrutura['total_elementos']}</p>
                </div>
                """, unsafe_allow_html=True)
                
                # Elementos encontrados
                st.subheader("‚úÖ Elementos Encontrados")
                for elemento, presente in estrutura['elementos_encontrados'].items():
                    icon = "‚úÖ" if presente else "‚ùå"
                    st.write(f"{icon} {elemento.replace('_', ' ').title()}")
                
                if estrutura['elementos_faltando']:
                    st.subheader("‚ö†Ô∏è Elementos Faltando")
                    for elemento in estrutura['elementos_faltando']:
                        st.write(f"‚Ä¢ {elemento.replace('_', ' ').title()}")
            
            with col2:
                st.subheader("üîç Valida√ß√£o de Honestidade")
                honestidade = processor.verificar_honestidade_curriculo(texto_extraido)
                
                # Status de honestidade
                status_items = [
                    ("Datas consistentes", honestidade['datas_consistentes']),
                    ("Informa√ß√µes verific√°veis", honestidade['informacoes_verificaveis']),
                    ("Detalhamento adequado", honestidade['nivel_detalhamento_adequado'])
                ]
                
                for label, status in status_items:
                    icon = "‚úÖ" if status else "‚ùå"
                    st.write(f"{icon} {label}")
                
                if honestidade['alertas_inconsistencia']:
                    st.subheader("‚ö†Ô∏è Alertas")
                    for alerta in honestidade['alertas_inconsistencia']:
                        st.warning(f"‚Ä¢ {alerta}")
                
                # Indicadores espec√≠ficos
                if 'indicadores' in honestidade:
                    st.subheader("üìà Indicadores")
                    indicadores = honestidade['indicadores']
                    for key, value in indicadores.items():
                        icon = "‚úÖ" if value else "‚ùå"
                        label = key.replace('_', ' ').title()
                        st.write(f"{icon} {label}")
            
            # Palavras-chave extra√≠das
            st.subheader("üîë Palavras-chave Extra√≠das")
            palavras = processor.extrair_palavras_chave_curriculo(texto_extraido)
            
            if palavras:
                # Organiza em colunas
                cols = st.columns(3)
                for i, palavra in enumerate(palavras[:15]):  # Mostra at√© 15 palavras
                    with cols[i % 3]:
                        st.badge(palavra, outline=True)
            else:
                st.info("Nenhuma palavra-chave identificada automaticamente.")
            
            # An√°lise de formata√ß√£o
            st.subheader("üé® An√°lise de Formata√ß√£o")
            formatacao = processor.analisar_formatacao_documento(texto_extraido)
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("P√°ginas estimadas", f"{formatacao['tamanho_paginas']}")
            with col2:
                st.metric("Total caracteres", formatacao['metricas_texto']['total_caracteres'])
            with col3:
                st.metric("Se√ß√µes encontradas", formatacao['estrutura_secoes']['total_secoes'])
            
        except Exception as e:
            st.error(f"‚ùå Erro ao processar curr√≠culo: {str(e)}")

def testar_agente_1():
    """Interface para testar o Agente 1 - MPC"""
    
    st.header("üîç Agente 1 - Mapa de Palavras-Chave (MPC)")
    st.markdown("**Teste a coleta real de vagas e valida√ß√£o com IA seguindo a metodologia Carolina Martins**")
    
    col1, col2 = st.columns([1, 1])
    
    with col1:
        st.subheader("‚öôÔ∏è Configura√ß√£o da Busca")
        
        # Inputs para busca
        area_interesse = st.selectbox(
            "√Årea de Interesse",
            ["Marketing", "Tecnologia", "Vendas", "Recursos Humanos", "Financeiro", "Log√≠stica", "Jur√≠dico"],
            help="√Årea principal de atua√ß√£o"
        )
        
        cargo_objetivo = st.text_input(
            "Cargo Objetivo",
            placeholder="Ex: Analista de Marketing Digital",
            help="Cargo espec√≠fico que voc√™ deseja"
        )
        
        total_vagas = st.slider(
            "Total de Vagas a Coletar",
            min_value=10,
            max_value=100,
            value=50,
            step=10,
            help="Quanto mais vagas, melhor a an√°lise (mas demora mais)"
        )
        
        # Configura√ß√µes avan√ßadas
        with st.expander("üîß Configura√ß√µes Avan√ßadas"):
            localizacao = st.text_input("Localiza√ß√£o", value="S√£o Paulo, SP")
            testar_ia = st.checkbox("Testar valida√ß√£o com IA", value=True)
            mostrar_detalhes = st.checkbox("Mostrar detalhes da coleta", value=False)
    
    with col2:
        st.subheader("üìã Processo MPC:")
        st.markdown("""
        **1. Coleta de Vagas (Real):**
        - üåê Indeed (web scraping)
        - üíº InfoJobs (web scraping)  
        - üîç Catho (web scraping)
        - üí° LinkedIn Jobs (limitado)
        
        **2. Extra√ß√£o de Palavras-chave:**
        - ü§ñ An√°lise autom√°tica das descri√ß√µes
        - üìù Categoriza√ß√£o (t√©cnica, comportamental, digital)
        - üìä Ranking por frequ√™ncia
        
        **3. Valida√ß√£o com IA:**
        - üß† OpenAI GPT-3.5-turbo ou
        - üîÆ Anthropic Claude-3-haiku
        - ‚úÖ Aprova√ß√£o/rejei√ß√£o inteligente
        - üí° Sugest√µes de melhorias
        
        **4. Prioriza√ß√£o Final:**
        - üéØ Essenciais (70%+ das vagas)
        - ‚≠ê Importantes (40-69%)
        - üìå Complementares (<40%)
        """)
    
    # Bot√£o para executar
    if st.button("üöÄ Executar MPC Completo", type="primary"):
        if cargo_objetivo.strip():
            executar_mpc(area_interesse, cargo_objetivo, localizacao, total_vagas, testar_ia, mostrar_detalhes)
        else:
            st.error("Por favor, informe o cargo objetivo.")

def executar_mpc(area, cargo, localizacao, total_vagas, testar_ia, mostrar_detalhes):
    """Executa o processo MPC completo"""
    
    # Progress bar
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    try:
        # Etapa 1: Coleta de Vagas
        status_text.text("üåê Coletando vagas reais...")
        progress_bar.progress(20)
        
        scraper = JobScraper()
        vagas = scraper.coletar_vagas_multiplas_fontes(
            area_interesse=area,
            cargo_objetivo=cargo,
            localizacao=localizacao,
            total_vagas_desejadas=total_vagas
        )
        
        progress_bar.progress(50)
        
        if not vagas:
            st.error("‚ùå Nenhuma vaga foi coletada. Verifique sua conex√£o com a internet.")
            return
        
        # Etapa 2: Extra√ß√£o de Palavras-chave
        status_text.text("üîç Extraindo palavras-chave...")
        progress_bar.progress(70)
        
        palavras_contador = scraper.extrair_palavras_chave_descricoes(vagas)
        
        # Categoriza palavras
        palavras_por_categoria = categorizar_palavras(palavras_contador)
        
        # Etapa 3: Valida√ß√£o com IA (opcional)
        resultado_ia = None
        if testar_ia and (palavras_por_categoria['tecnica'] or palavras_por_categoria['comportamental']):
            status_text.text("ü§ñ Validando com IA...")
            progress_bar.progress(90)
            
            try:
                validator = AIValidator()
                resultado_ia = asyncio.run(validator.validar_palavras_chave(
                    palavras_por_categoria=palavras_por_categoria,
                    area=area,
                    cargo=cargo,
                    contexto_vagas=[vaga['descricao'][:200] for vaga in vagas[:3]]
                ))
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Erro na valida√ß√£o IA: {e}")
        
        progress_bar.progress(100)
        status_text.text("‚úÖ MPC conclu√≠do!")
        
        # Exibe resultados
        exibir_resultados_mpc(vagas, palavras_contador, palavras_por_categoria, resultado_ia, mostrar_detalhes)
        
    except Exception as e:
        st.error(f"‚ùå Erro durante execu√ß√£o do MPC: {str(e)}")
        progress_bar.progress(0)

def categorizar_palavras(palavras_contador):
    """Categoriza palavras-chave por tipo"""
    
    # Categorias baseadas na metodologia Carolina Martins
    categorias = {
        'tecnica': ['excel', 'power bi', 'sql', 'python', 'java', 'javascript', 'tableau', 'sap', 'oracle'],
        'comportamental': ['lideran√ßa', 'gest√£o', 'comunica√ß√£o', 'negocia√ß√£o', 'anal√≠tico', 'estrat√©gico', 'proativo', 'criativo'],
        'digital': ['analytics', 'digital', 'online', 'seo', 'sem', 'social media', 'marketing digital', 'e-commerce']
    }
    
    palavras_por_categoria = {
        'tecnica': [],
        'comportamental': [],
        'digital': [],
        'outras': []
    }
    
    for palavra, freq in palavras_contador.items():
        categorizada = False
        for categoria, lista_palavras in categorias.items():
            if any(cat_palavra in palavra.lower() for cat_palavra in lista_palavras):
                palavras_por_categoria[categoria].append(palavra)
                categorizada = True
                break
        
        if not categorizada:
            palavras_por_categoria['outras'].append(palavra)
    
    return palavras_por_categoria

def exibir_resultados_mpc(vagas, palavras_contador, palavras_por_categoria, resultado_ia, mostrar_detalhes):
    """Exibe os resultados do processo MPC"""
    
    st.subheader("üìä Resultados do MPC")
    
    # M√©tricas principais
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Vagas Coletadas", len(vagas))
    with col2:
        st.metric("Palavras-chave √önicas", len(palavras_contador))
    with col3:
        fontes = set([vaga.get('fonte', 'unknown') for vaga in vagas])
        st.metric("Fontes Utilizadas", len(fontes))
    with col4:
        if resultado_ia:
            st.metric("Aprovadas pela IA", len(resultado_ia.get('aprovadas', [])))
    
    # Distribui√ß√£o de fontes
    st.subheader("üåê Distribui√ß√£o por Fonte")
    fonte_counts = {}
    for vaga in vagas:
        fonte = vaga.get('fonte', 'unknown')
        fonte_counts[fonte] = fonte_counts.get(fonte, 0) + 1
    
    cols = st.columns(len(fonte_counts))
    for i, (fonte, count) in enumerate(fonte_counts.items()):
        with cols[i]:
            st.metric(fonte.title(), count)
    
    # Palavras-chave por categoria
    st.subheader("üîë Palavras-chave por Categoria")
    
    tabs = st.tabs(["üîß T√©cnicas", "üß† Comportamentais", "üíª Digitais", "üìù Outras"])
    
    categorias = ['tecnica', 'comportamental', 'digital', 'outras']
    for i, categoria in enumerate(categorias):
        with tabs[i]:
            palavras = palavras_por_categoria[categoria][:20]  # Top 20
            if palavras:
                cols = st.columns(4)
                for j, palavra in enumerate(palavras):
                    with cols[j % 4]:
                        freq = palavras_contador.get(palavra, 1)
                        st.button(f"{palavra} ({freq})", key=f"{categoria}_{j}")
            else:
                st.info("Nenhuma palavra encontrada nesta categoria.")
    
    # Resultados da valida√ß√£o IA
    if resultado_ia:
        st.subheader("ü§ñ Valida√ß√£o com IA")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**‚úÖ Palavras Aprovadas:**")
            if resultado_ia.get('aprovadas'):
                for palavra in resultado_ia['aprovadas'][:10]:
                    st.success(f"‚úì {palavra}")
            else:
                st.info("Nenhuma palavra aprovada.")
        
        with col2:
            st.markdown("**‚ùå Palavras Rejeitadas:**")
            if resultado_ia.get('rejeitadas'):
                for item in resultado_ia['rejeitadas'][:5]:
                    if isinstance(item, dict):
                        palavra = item.get('palavra', '')
                        motivo = item.get('motivo', '')
                        st.error(f"‚úó {palavra} - {motivo}")
                    else:
                        st.error(f"‚úó {item}")
            else:
                st.info("Nenhuma palavra rejeitada.")
        
        # Sugest√µes da IA
        if resultado_ia.get('sugestoes_novas'):
            st.markdown("**üí° Sugest√µes da IA:**")
            for sugestao in resultado_ia['sugestoes_novas']:
                st.info(f"üí° {sugestao}")
        
        # Metadados
        with st.expander("üîç Detalhes da Valida√ß√£o IA"):
            st.write(f"**Modelo usado:** {resultado_ia.get('modelo_usado', 'N/A')}")
            st.write(f"**Confian√ßa:** {resultado_ia.get('confianca', 0):.1%}")
            if resultado_ia.get('comentarios'):
                st.write(f"**Coment√°rios:** {resultado_ia['comentarios']}")
    
    # Detalhes das vagas (opcional)
    if mostrar_detalhes:
        with st.expander("üìã Detalhes das Vagas Coletadas"):
            for i, vaga in enumerate(vagas[:10]):  # Mostra apenas 10 primeiras
                st.markdown(f"**{i+1}. {vaga['titulo']}** - {vaga['empresa']}")
                st.markdown(f"*{vaga['localizacao']} | Fonte: {vaga['fonte']}*")
                st.markdown(f"{vaga['descricao'][:200]}...")
                st.markdown("---")

def testar_integracao():
    """Interface para testar integra√ß√£o completa"""
    
    st.header("üìä Resultados Integrados")
    st.markdown("**Visualize como os Agentes 0 e 1 trabalham juntos**")
    
    st.info("üöß Em desenvolvimento: Esta se√ß√£o mostrar√° a integra√ß√£o completa entre an√°lise de CV e MPC para gerar recomenda√ß√µes personalizadas.")
    
    # Placeholder para funcionalidade futura
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìÑ Resumo do CV Analisado")
        st.markdown("""
        - Score de qualidade
        - Elementos presentes/faltantes
        - Palavras-chave atuais
        - Gaps identificados
        """)
    
    with col2:
        st.subheader("üîç Resultado do MPC")
        st.markdown("""
        - Palavras-chave do mercado
        - Valida√ß√£o com IA
        - Prioriza√ß√£o por frequ√™ncia
        - Recomenda√ß√µes espec√≠ficas
        """)
    
    st.subheader("üéØ Pr√≥ximas Funcionalidades")
    st.markdown("""
    - **Gap Analysis:** Compara√ß√£o entre CV atual e mercado
    - **Recomenda√ß√µes Personalizadas:** Sugest√µes baseadas na metodologia
    - **Roadmap de Melhoria:** Plano de a√ß√£o estruturado
    - **Export de Resultados:** PDF com an√°lise completa
    """)

if __name__ == "__main__":
    main()